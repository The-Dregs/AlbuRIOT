---
alwaysApply: true
---

# Enemy AI Creation Guidelines

Based on the BungisngisAI, TikbalangAI, and KapreAI refactoring and proven patterns from AmomongoAI and BerberokaAI.

**Last Updated**: Includes fixes for movement speed management, patrol wait handling, rotation locking for charge/dash attacks, and comprehensive busy state management.

## Core Principles

### 1. Only One Action At A Time
**NEVER allow multiple actions to overlap.** Use busy state management to ensure sequential execution:
- Basic attacks, special abilities, and movements must be mutually exclusive
- Use `BeginAction()` / `EndAction()` for proper state management
- Track coroutine state to prevent interruptions

### 2. Proper Coroutine Management
All non-instant actions MUST be handled as coroutines with proper cleanup:
- Track active coroutines with `Coroutine` fields
- Clear coroutine references when they complete
- Prevent new actions if a coroutine is active

### 3. Busy State System
Always check busy states before starting new actions:
- `isBusy` - Set by `BeginAction()`, cleared by `EndAction()`
- `globalBusyTimer` - Post-action cooldown enforced by base class
- Custom coroutine tracking (e.g., `activeAbility`, `basicRoutine`)
- `aiState` - Must be set to `AIState.Idle` when AI is stationary (patrol wait, reached destination, etc.)

### 4. Movement Speed Management
**CRITICAL**: The animator speed parameter must show 0 when the AI is stopped:
- `GetMoveSpeed()` must return 0 when `aiState == AIState.Idle`
- During patrol wait phase, set `aiState = AIState.Idle` and stop movement with `controller.SimpleMove(Vector3.zero)`
- Base speed values (e.g., patrol speed of 2) should NOT be visible when AI is stationary

## Required Imports

```csharp
using UnityEngine;
using Photon.Pun;
using AlbuRIOT.AI.BehaviorTree;
using System.Collections;
using System.Collections.Generic;  // Required for HashSet (charge/dash tracking)
```

## Required Components

### Fields

#### Timer Tracking
```csharp
private float lastLaughTime = -9999f;
private float lastPoundTime = -9999f;
private float lastAnySkillRecoveryEnd = -9999f;  // For global skill locks
private float lastAnySkillRecoveryStart = -9999f; // For gradual speed recovery
```

#### Coroutine Tracking
```csharp
private Coroutine activeAbility;    // Track special ability coroutines
private Coroutine basicRoutine;     // Track basic attack coroutines
private AudioSource audioSource;    // Shared audio component
```

#### EnemyData Fields (ScriptableObject)
Basic attack parameters are defined in `EnemyData`:
```csharp
// In EnemyData ScriptableObject
public float attackWindup = 0.3f;  // Basic attack windup time
public float attackRange = 2.2f;
public float attackCooldown = 1.25f;
public float attackMoveLock = 0.35f;
```

#### Inspector Fields Pattern
```csharp
[Header("Ability Name (Attack Type)")]
public int abilityDamage = 15;
public float abilityRadius = 7f;      // Use "radius", not "range" for damage areas
public float abilityWindup = 0.5f;    // Windup before damage
public float abilityCooldown = 20f;   // Time between uses

// Separate VFX for windup and impact
public GameObject abilityWindupVFX;
public GameObject abilityImpactVFX;
public Vector3 abilityWindupVFXOffset = Vector3.zero;
public float abilityWindupVFXScale = 1.0f;
public Vector3 abilityImpactVFXOffset = Vector3.zero;
public float abilityImpactVFXScale = 1.0f;

// Separate SFX for windup and impact
public AudioClip abilityWindupSFX;
public AudioClip abilityImpactSFX;

// Separate animation triggers for windup and impact/main
public string abilityWindupTrigger = "AbilityWindup";  // Trigger for windup phase
public string abilityMainTrigger = "AbilityMain";      // Trigger for impact/main phase
```

#### Charge/Dash Inspector Fields
```csharp
[Header("Charge Attack")]
public int chargeDamage = 35;
public float chargeCooldown = 15f;
public float chargeWindup = 2f;
public float chargeDuration = 2f;
public float chargeSpeed = 14f;
public float chargeHitRadius = 1.7f;
public float chargeMinDistance = 2f;
public GameObject chargeVFX; // windup
public AudioClip chargeSFX;  // windup
public GameObject chargeImpactVFX;
public Vector3 chargeVFXOffset = Vector3.zero;
public float chargeVFXScale = 1.0f;
public Vector3 chargeImpactVFXOffset = Vector3.zero;
public float chargeImpactVFXScale = 1.0f;
public AudioClip chargeImpactSFX;

// Separate triggers for windup, charge, and stoppage
public string chargeWindupTrigger = "ChargeWindup";
public string chargeTrigger = "Charge";
public string skillStoppageTrigger = "SkillStoppage";
```

**Note**: For charge/dash attacks and other abilities with dedicated windup (e.g., Stomp, Slam), use separate animation triggers for windup, main action, and stoppage phases.

#### Teleporting Attack Inspector Fields
```csharp
[Header("Teleport Strike")]
public int teleportStrikeDamage = 30;
public float teleportStrikeRadius = 1.6f;
public float teleportWindup = 0.5f;
public float teleportCooldown = 9f;
public float teleportBehindDistance = 1.2f;
public GameObject teleportWindupVFX;
public GameObject teleportImpactVFX;
public Vector3 teleportVFXOffset = Vector3.zero;
public float teleportVFXScale = 1.0f;
public Vector3 teleportImpactVFXOffset = Vector3.zero;
public float teleportImpactVFXScale = 1.0f;
public AudioClip teleportWindupSFX;
public AudioClip teleportImpactSFX;
public string teleportTrigger = "Teleport";
```

**Note**: For teleporting attacks, capture target position when ability is initiated (in `Start` method), NOT during windup. Teleport to where player was FIRST LOCATED.

#### Recovery System (for specials)
```csharp
[Header("Animation")]
// Special ability triggers (REQUIRED for all skills)
public string abilityWindupTrigger = "AbilityWindup";  // REQUIRED: separate windup trigger
public string abilityMainTrigger = "AbilityMain";     // REQUIRED: separate main/impact trigger
public string skillStoppageTrigger = "SkillStoppage";  // For stoppage phase after skills

[Header("Skill Selection Tuning")]
public float abilityStoppageTime = 1f;    // AI frozen after attack
public float abilityRecoveryTime = 0.5f;  // AI can move but skill on cooldown
```

**Note**: All skills MUST use separate animation triggers for windup and impact/main phases. Basic attack triggers (`attackWindupTrigger` and `attackImpactTrigger`) are defined in `BaseEnemyAI` and use `EnemyData.attackWindup` from the ScriptableObject.

**Animation Parameter**: Add a boolean animator parameter named `"Exhausted"` that gets set to `true` when 75% of the stoppage time remains (at 25% elapsed) and `false` when the stoppage phase ends. This allows animations to respond to the exhaustion state. **This is for skills only, not basic attacks.**

### Core Methods Pattern

#### 1. Basic Attack Structure
```csharp
protected override void PerformBasicAttack()
{
    if (basicRoutine != null) return;  // Prevent overlap
    if (activeAbility != null) return; // Don't interrupt special abilities
    if (isBusy || globalBusyTimer > 0f) return; // Don't interrupt other actions
    if (enemyData == null) return;
    if (Time.time - lastAttackTime < enemyData.attackCooldown) return;

    var target = blackboard.Get<Transform>("target");
    if (target == null) return;

    basicRoutine = StartCoroutine(CoBasicAttack(target));
}

private IEnumerator CoBasicAttack(Transform target)
{
    BeginAction(AIState.BasicAttack);  // Set busy state
    
    // Windup animation trigger (use separate triggers if available)
    if (animator != null)
    {
        if (HasTrigger(attackWindupTrigger))
            animator.SetTrigger(attackWindupTrigger);
        else if (HasTrigger(attackTrigger))
            animator.SetTrigger(attackTrigger);
    }

    // Windup phase - freeze movement during windup (NO facing for basic attacks)
    float windup = Mathf.Max(0f, enemyData.attackWindup);
    while (windup > 0f)
    {
        windup -= Time.deltaTime;
        if (controller != null && controller.enabled) controller.SimpleMove(Vector3.zero);
        yield return null;
    }

    // Impact animation trigger
    if (animator != null && HasTrigger(attackImpactTrigger))
        animator.SetTrigger(attackImpactTrigger);

    // Apply damage after windup
    float radius = Mathf.Max(0.8f, enemyData.attackRange);
    Vector3 center = transform.position + transform.forward * (enemyData.attackRange * 0.5f);
    var cols = Physics.OverlapSphere(center, radius, LayerMask.GetMask("Player"));
    foreach (var c in cols)
    {
        var ps = c.GetComponentInParent<PlayerStats>();
        if (ps != null) ps.TakeDamage(enemyData.basicDamage);
    }

    // Post-stop using attackMoveLock duration
    float post = Mathf.Max(0.1f, enemyData.attackMoveLock);
    while (post > 0f)
    {
        post -= Time.deltaTime;
        if (controller != null && controller.enabled) controller.SimpleMove(Vector3.zero);
        yield return null;
    }

    lastAttackTime = Time.time;
    attackLockTimer = enemyData.attackMoveLock;
    basicRoutine = null;  // Clear tracking
    EndAction();  // Clear busy state
}
```

#### 2. Special Ability Structure
```csharp
private bool CanAbility()
{
    if (activeAbility != null) return false;         // No active ability
    if (basicRoutine != null) return false;          // No active basic attack
    if (isBusy || globalBusyTimer > 0f) return false; // No global busy state
    if (Time.time - lastAbilityTime < abilityCooldown) return false;
    if (Time.time - lastAnySkillRecoveryEnd < 4f) return false; // Global skill lock
    
    var target = blackboard.Get<Transform>("target");
    if (target == null) return false;
    return Vector3.Distance(transform.position, target.position) <= abilityRadius + 0.5f;
}

private void StartAbility()
{
    if (activeAbility != null) return;
    if (enemyData != null) lastAttackTime = Time.time;
    activeAbility = StartCoroutine(CoAbility());
}

private IEnumerator CoAbility()
{
    BeginAction(AIState.Special1);  // Choose appropriate state
    
    // Windup phase - separate trigger, VFX, and SFX
    if (animator != null && HasTrigger(abilityWindupTrigger))
        animator.SetTrigger(abilityWindupTrigger);
    
    if (audioSource != null && abilityWindupSFX != null) 
        audioSource.PlayOneShot(abilityWindupSFX);
    
    GameObject wind = null;
    if (abilityWindupVFX != null)
    {
        wind = Instantiate(abilityWindupVFX, transform);
        wind.transform.localPosition = abilityWindupVFXOffset;
        if (abilityWindupVFXScale > 0f) 
            wind.transform.localScale = Vector3.one * abilityWindupVFXScale;
    }
    
    // Windup phase - freeze movement (NO facing for regular attacks; charge/leap attacks face during windup)
    float windup = Mathf.Max(0f, abilityWindup);
    while (windup > 0f)
    {
        windup -= Time.deltaTime;
        if (controller != null && controller.enabled)
            controller.SimpleMove(Vector3.zero);
        yield return null;
    }
    if (wind != null) Destroy(wind);

    // Impact/Main phase - separate trigger, VFX, and SFX
    if (animator != null && HasTrigger(abilityMainTrigger))
        animator.SetTrigger(abilityMainTrigger);
    
    if (abilityImpactVFX != null)
    {
        var fx = Instantiate(abilityImpactVFX, transform);
        fx.transform.localPosition = abilityImpactVFXOffset;
        if (abilityImpactVFXScale > 0f) 
            fx.transform.localScale = Vector3.one * abilityImpactVFXScale;
    }
    
    if (audioSource != null && abilityImpactSFX != null) 
        audioSource.PlayOneShot(abilityImpactSFX);

    // Apply damage (cone, strip, sphere, or projectile)
    // ... damage logic ...

    // Stoppage recovery (AI frozen after attack)
    if (abilityStoppageTime > 0f)
    {
        // Stoppage animation trigger for skills
        if (animator != null && HasTrigger(skillStoppageTrigger)) animator.SetTrigger(skillStoppageTrigger);
        
        float stopTimer = abilityStoppageTime;
        float quarterStoppage = abilityStoppageTime * 0.75f;
        
        while (stopTimer > 0f)
        {
            stopTimer -= Time.deltaTime;
            if (controller != null && controller.enabled)
                controller.SimpleMove(Vector3.zero);
            
            // Set Exhausted boolean parameter when 75% of stoppage time remains (skills only)
            if (stopTimer <= quarterStoppage && animator != null && !animator.GetBool("Exhausted"))
            {
                animator.SetBool("Exhausted", true);
            }
            
            yield return null;
        }
        
        // Clear Exhausted boolean parameter
        if (animator != null) animator.SetBool("Exhausted", false);
    }

    // End busy state so AI can move during recovery
    EndAction();

    // Recovery time (AI can move but skill still on cooldown, gradual speed recovery)
    if (abilityRecoveryTime > 0f)
    {
        lastAnySkillRecoveryStart = Time.time;  // For gradual speed
        float recovery = abilityRecoveryTime;
        while (recovery > 0f)
        {
            recovery -= Time.deltaTime;
            // AI can move during recovery - no movement freeze
            yield return null;
        }
        lastAnySkillRecoveryEnd = Time.time;
    }
    else
    {
        lastAnySkillRecoveryEnd = Time.time;
    }

    activeAbility = null;
    lastAbilityTime = Time.time;  // Set cooldown timer after all recovery is done
}
```

## Advanced Features

### Movement Speed Management
**CRITICAL**: Speed must return 0 when AI is stopped to prevent animator speed parameter from showing incorrect values.

```csharp
protected override float GetMoveSpeed()
{
    // Return 0 if AI is busy or has active ability (should be stopped)
    if (isBusy || globalBusyTimer > 0f || activeAbility != null || basicRoutine != null)
    {
        return 0f;
    }
    
    // If AI is idle (not patrolling or chasing), return 0
    // This prevents speed from showing base speed value when AI is stationary
    if (aiState == AIState.Idle)
    {
        return 0f;
    }
    
    float baseSpeed = base.GetMoveSpeed();
    
    // If we're in recovery phase, gradually increase speed from 0.3 to 1.0
    if (Time.time >= lastAnySkillRecoveryStart && 
        Time.time <= lastAnySkillRecoveryEnd && 
        lastAnySkillRecoveryStart >= 0f)
    {
        float recoveryDuration = lastAnySkillRecoveryEnd - lastAnySkillRecoveryStart;
        if (recoveryDuration > 0f)
        {
            float elapsed = Time.time - lastAnySkillRecoveryStart;
            float progress = Mathf.Clamp01(elapsed / recoveryDuration);
            float speedMultiplier = Mathf.Lerp(0.3f, 1.0f, progress);  // Start at 30% speed
            return baseSpeed * speedMultiplier;
        }
    }
    
    return baseSpeed;
}
```

**Key Points:**
- **ALWAYS** check `isBusy`, `globalBusyTimer`, `activeAbility`, `basicRoutine` first
- **ALWAYS** check `aiState == AIState.Idle` before returning base speed
- Ensures animator speed parameter shows 0 when AI is stopped
- Prevents speed from getting "stuck" at base speed value (e.g., patrol speed of 2) when idle

### Global Post-Skill Lock
Prevent skill chaining with a mandatory cooldown after ANY skill's recovery:

```csharp
// In CanAbility() checks:
if (Time.time - lastAnySkillRecoveryEnd < 4f) return false;  // 4 second lock

// At end of CoAbility():
lastAnySkillRecoveryEnd = Time.time;  // Set this timer
```

### Damage Area Types

#### Cone Attack
```csharp
var all = Physics.OverlapSphere(transform.position, coneRadius, LayerMask.GetMask("Player"));
Vector3 fwd = new Vector3(transform.forward.x, 0f, transform.forward.z).normalized;
float halfAngle = Mathf.Clamp(coneAngle * 0.5f, 0f, 90f);
foreach (var c in all)
{
    Vector3 to = c.transform.position - transform.position;
    to.y = 0f;
    if (to.sqrMagnitude < 0.0001f) continue;
    float angle = Vector3.Angle(fwd, to.normalized);
    if (angle <= halfAngle)
    {
        var ps = c.GetComponentInParent<PlayerStats>();
        if (ps != null) ps.TakeDamage(damage);
    }
}
```

#### Strip/Shockwave Attack
```csharp
var all = Physics.OverlapSphere(transform.position + transform.forward * (stripRadius * 0.5f), 
                                 stripRadius, LayerMask.GetMask("Player"));
Vector3 fwd = new Vector3(transform.forward.x, 0f, transform.forward.z).normalized;
foreach (var c in all)
{
    Vector3 rel = c.transform.position - transform.position;
    rel.y = 0f;
    float along = Vector3.Dot(rel, fwd);
    float across = Vector3.Cross(fwd, rel.normalized).magnitude * rel.magnitude;
    if (along >= 0f && along <= stripRadius && Mathf.Abs(across) <= (stripWidth * 0.5f))
    {
        var ps = c.GetComponentInParent<PlayerStats>();
        if (ps != null) ps.TakeDamage(damage);
    }
}
```

#### Projectile System
```csharp
if (projectilePrefab != null && projectileCount > 0)
{
    float step = (projectileCount > 1) ? spreadAngle / (projectileCount - 1) : 0f;
    float startYaw = -spreadAngle * 0.5f;
    for (int i = 0; i < projectileCount; i++)
    {
        float angle = startYaw + step * i;
        Quaternion rot = transform.rotation * Quaternion.Euler(0f, angle, 0f);
        Vector3 spawnPos = transform.position + rot * spawnOffset;
        var projObj = Instantiate(projectilePrefab, spawnPos, rot);
        var proj = projObj.GetComponent<ProjectileComponent>();
        if (proj != null)
        {
            proj.damage = damage;
            proj.owner = this;
            proj.speed = projectileSpeed;
            proj.lifetime = projectileLifetime;
        }
    }
}
```

#### Charge/Dash Attack
```csharp
private IEnumerator CoCharge()
{
    BeginAction(AIState.Special1);
    
    // Capture charge direction before windup (where to charge)
    var target = blackboard.Get<Transform>("target");
    Vector3 chargeDirection = transform.forward; // Default to current forward
    if (target != null)
    {
        Vector3 toTarget = new Vector3(target.position.x, transform.position.y, target.position.z) - transform.position;
        if (toTarget.sqrMagnitude > 0.0001f)
        {
            chargeDirection = toTarget.normalized;
            // Set rotation once before windup
            transform.rotation = Quaternion.LookRotation(chargeDirection);
        }
    }
    
    // Windup animation trigger
    if (animator != null && HasTrigger(chargeWindupTrigger)) animator.SetTrigger(chargeWindupTrigger);
    // Windup VFX/SFX
    if (audioSource != null && chargeSFX != null)
    {
        audioSource.clip = chargeSFX;
        audioSource.loop = false;
        audioSource.Play();
    }
    GameObject windupFx = null;
    if (chargeVFX != null)
    {
        windupFx = Instantiate(chargeVFX, transform);
        windupFx.transform.localPosition = chargeVFXOffset;
        if (chargeVFXScale > 0f) windupFx.transform.localScale = Vector3.one * chargeVFXScale;
    }
    
    // Windup phase - lock rotation (don't face player)
    float windup = chargeWindup;
    while (windup > 0f)
    {
        windup -= Time.deltaTime;
        // Lock rotation during windup
        transform.rotation = Quaternion.LookRotation(chargeDirection);
        if (controller != null && controller.enabled) controller.SimpleMove(Vector3.zero);
        yield return null;
    }

    // End windup visuals/audio and play activation VFX/SFX
    if (audioSource != null && audioSource.clip == chargeSFX)
    {
        audioSource.Stop();
        audioSource.clip = null;
    }
    if (windupFx != null) Destroy(windupFx);
    if (chargeImpactVFX != null)
    {
        var fx = Instantiate(chargeImpactVFX, transform);
        fx.transform.localPosition = chargeImpactVFXOffset;
        if (chargeImpactVFXScale > 0f) fx.transform.localScale = Vector3.one * chargeImpactVFXScale;
    }
    if (audioSource != null && chargeImpactSFX != null) audioSource.PlayOneShot(chargeImpactSFX);

    // Charge animation trigger
    if (animator != null && HasTrigger(chargeTrigger)) animator.SetTrigger(chargeTrigger);

    // Charge in locked direction (set before windup)
    float chargeTime = chargeDuration;
    HashSet<PlayerStats> hitPlayers = new HashSet<PlayerStats>(); // Track players already hit
    
    while (chargeTime > 0f)
    {
        if (controller != null && controller.enabled)
        {
            controller.Move(chargeDirection * chargeSpeed * Time.deltaTime);
        }

        // Check for hits during charge - ONE DAMAGE PER PLAYER
        var hitColliders = Physics.OverlapSphere(transform.position, chargeHitRadius);
        foreach (var hit in hitColliders)
        {
            if (hit.CompareTag("Player"))
            {
                var playerStats = hit.GetComponent<PlayerStats>();
                if (playerStats != null && !hitPlayers.Contains(playerStats))
                {
                    playerStats.TakeDamage(chargeDamage);
                    hitPlayers.Add(playerStats);
                }
            }
        }

        chargeTime -= Time.deltaTime;
        yield return null;
    }

    // Stoppage recovery (AI frozen after attack)
    if (chargeStoppageTime > 0f)
    {
        // Stoppage animation trigger for skills
        if (animator != null && HasTrigger(skillStoppageTrigger)) animator.SetTrigger(skillStoppageTrigger);
        
        float stopTimer = chargeStoppageTime;
        float quarterStoppage = chargeStoppageTime * 0.75f;
        
        while (stopTimer > 0f)
        {
            stopTimer -= Time.deltaTime;
            if (controller != null && controller.enabled)
                controller.SimpleMove(Vector3.zero);
            
            // Set Exhausted boolean parameter when 75% of stoppage time remains (skills only)
            if (stopTimer <= quarterStoppage && animator != null && !animator.GetBool("Exhausted"))
            {
                animator.SetBool("Exhausted", true);
            }
            
            yield return null;
        }
        
        // Clear Exhausted boolean parameter
        if (animator != null) animator.SetBool("Exhausted", false);
    }

    // Recovery time (AI can move but skill still on cooldown)
    if (chargeRecoveryTime > 0f)
    {
        lastAnySkillRecoveryStart = Time.time;
        float recovery = chargeRecoveryTime;
        while (recovery > 0f)
        {
            recovery -= Time.deltaTime;
            yield return null;
        }
    }

    activeAbility = null;
    lastChargeTime = Time.time;
    lastAnySkillRecoveryEnd = Time.time;
    EndAction();
}
```

**Key Points for Charge/Dash:**
- **CRITICAL**: Capture charge/leap direction BEFORE windup starts, then lock rotation during windup
- **CRITICAL**: Lock rotation during windup (don't face player) - rotation is set once before windup and locked
- **CRITICAL**: Use `HashSet<PlayerStats>` to track hit players and ensure one damage per player
- Use `controller.Move()` instead of `controller.SimpleMove()` for physics-based movement
- Charge/leap direction should be calculated from target position before windup, then locked
- Separate animation triggers for windup, charge/leap, and stoppage
- AI frozen during windup AND during charge/leap (no other actions possible)
- **NOTE**: Tree Slam (leap) follows the same pattern as Charge attacks - lock rotation during windup

#### Teleporting Attack
```csharp
private void StartTeleportStrike()
{
    if (activeAbility != null) return;
    if (enemyData != null) lastAttackTime = Time.time;
    
    // Capture target position when ability is initiated (FIRST LOCATED)
    var target = blackboard.Get<Transform>("target");
    Vector3 capturedPos = target != null ? target.position : transform.position;
    Vector3 capturedForward = target != null ? target.forward : Vector3.forward;
    
    activeAbility = StartCoroutine(CoTeleportStrike(capturedPos, capturedForward));
}

private IEnumerator CoTeleportStrike(Vector3 capturedPos, Vector3 capturedForward)
{
    BeginAction(AIState.Special1);
    
    // Windup phase - separate trigger, VFX, and SFX
    if (animator != null && HasTrigger(teleportWindupTrigger))
        animator.SetTrigger(teleportWindupTrigger);
    if (audioSource != null && teleportWindupSFX != null) 
        audioSource.PlayOneShot(teleportWindupSFX);
    GameObject wind = null;
    if (teleportWindupVFX != null)
    {
        wind = Instantiate(teleportWindupVFX, transform);
        wind.transform.localPosition = teleportVFXOffset;
        if (teleportVFXScale > 0f) 
            wind.transform.localScale = Vector3.one * teleportVFXScale;
    }
    
    // Windup phase - freeze movement (NO facing for teleport attacks)
    float windup = Mathf.Max(0f, teleportWindup);
    while (windup > 0f)
    {
        windup -= Time.deltaTime;
        if (controller != null && controller.enabled)
            controller.SimpleMove(Vector3.zero);
        yield return null;
    }
    if (wind != null) Destroy(wind);

    // Teleport behind captured position (where player was FIRST LOCATED)
    Vector3 behind = capturedPos - capturedForward * Mathf.Max(0.2f, teleportBehindDistance);
    behind.y = transform.position.y;
    
    // Disable CharacterController to allow position change
    if (controller != null)
    {
        controller.enabled = false;
        transform.position = behind;
        controller.enabled = true;
    }
    else
    {
        transform.position = behind;
    }
    
    // Face captured position
    Vector3 dir = (capturedPos - transform.position);
    dir.y = 0f;
    if (dir.sqrMagnitude > 0.0001f)
        transform.rotation = Quaternion.LookRotation(dir.normalized);
        
    if (teleportImpactVFX != null)
    {
        var fx = Instantiate(teleportImpactVFX, transform);
        fx.transform.localPosition = teleportImpactVFXOffset;
        if (teleportImpactVFXScale > 0f) fx.transform.localScale = Vector3.one * teleportImpactVFXScale;
    }
    if (audioSource != null && teleportImpactSFX != null) audioSource.PlayOneShot(teleportImpactSFX);

    var cols = Physics.OverlapSphere(transform.position, teleportStrikeRadius, LayerMask.GetMask("Player"));
    foreach (var c in cols)
    {
        var ps = c.GetComponentInParent<PlayerStats>();
        if (ps != null) ps.TakeDamage(teleportStrikeDamage);
    }

    // Stoppage recovery (AI frozen after attack)
    if (teleportStoppageTime > 0f)
    {
        if (animator != null && HasTrigger(skillStoppageTrigger)) animator.SetTrigger(skillStoppageTrigger);
        
        float stopTimer = teleportStoppageTime;
        float quarterStoppage = teleportStoppageTime * 0.75f;
        
        while (stopTimer > 0f)
        {
            stopTimer -= Time.deltaTime;
            if (controller != null && controller.enabled)
                controller.SimpleMove(Vector3.zero);
            
            // Set Exhausted boolean parameter when 75% of stoppage time remains (skills only)
            if (stopTimer <= quarterStoppage && animator != null && !animator.GetBool("Exhausted"))
            {
                animator.SetBool("Exhausted", true);
            }
            
            yield return null;
        }
        
        // Clear Exhausted boolean parameter
        if (animator != null) animator.SetBool("Exhausted", false);
    }

    // End busy state so AI can move during recovery
    EndAction();

    // Recovery time (AI can move but skill still on cooldown, gradual speed recovery)
    if (teleportRecoveryTime > 0f)
    {
        lastAnySkillRecoveryStart = Time.time;
        float recovery = teleportRecoveryTime;
        while (recovery > 0f)
        {
            recovery -= Time.deltaTime;
            yield return null;
        }
        lastAnySkillRecoveryEnd = Time.time;
    }
    else
    {
        lastAnySkillRecoveryEnd = Time.time;
    }

    activeAbility = null;
    lastTeleportTime = Time.time;
}
```

**Key Points for Teleporting Attacks:**
- **CRITICAL**: Capture target position and forward direction when ability is initiated (in `StartTeleportStrike()`), NOT during windup
- **CRITICAL**: Teleport to the CAPTURED position (where player was FIRST LOCATED), not current position
- **NO facing during windup** - just freeze movement (teleport attacks don't need directional facing during windup)
- Disable CharacterController before teleporting, re-enable after
- Teleport behind captured position using `capturedForward`
- Face captured position after teleport (before applying damage)
- Apply damage at teleport destination

## Behavior Tree Structure

```csharp
protected override void BuildBehaviorTree()
{
    var updateTarget = new ActionNode(blackboard, UpdateTarget, "update_target");
    var hasTarget = new ConditionNode(blackboard, HasTarget, "has_target");
    var targetInDetection = new ConditionNode(blackboard, TargetInDetectionRange, "in_detect_range");
    var moveToTarget = new ActionNode(blackboard, MoveTowardsTarget, "move_to_target");
    var targetInAttack = new ConditionNode(blackboard, TargetInAttackRange, "in_attack_range");
    
    // For coroutine-based basic attacks, use inline lambda
    var basicAttack = new ActionNode(blackboard, () => { PerformBasicAttack(); return NodeState.Success; }, "basic");
    
    // Special abilities
    var canAbility1 = new ConditionNode(blackboard, CanAbility1, "can_ability1");
    var doAbility1 = new ActionNode(blackboard, () => { StartAbility1(); return NodeState.Success; }, "ability1");
    var canAbility2 = new ConditionNode(blackboard, CanAbility2, "can_ability2");
    var doAbility2 = new ActionNode(blackboard, () => { StartAbility2(); return NodeState.Success; }, "ability2");

    behaviorTree = new Selector(blackboard, "root")
        .Add(
            new Sequence(blackboard, "combat").Add(
                updateTarget,
                hasTarget,
                targetInDetection,
                new Selector(blackboard, "attack_opts").Add(
                    // Try abilities first (prioritized)
                    new Sequence(blackboard, "ability1_seq").Add(canAbility1, doAbility1),
                    new Sequence(blackboard, "ability2_seq").Add(canAbility2, doAbility2),
                    // Fall back to basic attack
                    new Sequence(blackboard, "basic_seq").Add(targetInAttack, basicAttack),
                    // Final fallback: move closer
                    moveToTarget
                )
            ),
            new ActionNode(blackboard, Patrol, "patrol")
        );
}
```

## Critical Checklist

Before finalizing any enemy AI:

- [ ] **No overlapping actions**: Every `CanX()` method checks:
  - `activeAbility != null`
  - `basicRoutine != null`
  - `isBusy || globalBusyTimer > 0f`
  
- [ ] **Proper coroutine cleanup**: Every coroutine:
  - Calls `BeginAction(AIState.X)` at start
  - Calls `EndAction()` at end
  - Clears its tracking field (e.g., `activeAbility = null`)
  
- [ ] **Cooldown management**: Every ability:
  - Sets its `lastXTime` AFTER all recovery phases complete
  - Uses cooldown values from Inspector (don't hardcode)
  
- [ ] **Movement freezing**: During stoppage/recovery:
  - Uses `controller.SimpleMove(Vector3.zero)` to halt movement during stoppage
  - Calls `EndAction()` immediately after stoppage (before recovery)
  - Recovery allows movement (no movement freeze)
  
- [ ] **Basic attack windup**: Basic attacks:
  - Use `enemyData.attackWindup` for windup duration
  - Use separate `attackWindupTrigger` and `attackImpactTrigger` if available
  - Freeze movement during windup, apply damage after windup
  
- [ ] **Recovery/stoppage timing**: Special abilities:
  - Call `EndAction()` immediately after stoppage (allows movement during recovery)
  - Recovery time allows movement with gradual speed recovery
  - Set `lastAnySkillRecoveryEnd` after recovery completes
  
- [ ] **Naming convention**: Use descriptive names:
  - `laughRadius` not `laughRange` (for damage areas)
  - `poundWidth` for strip width
  - `abilityStoppageTime` vs `abilityRecoveryTime` (distinct phases)
  
- [ ] **Debug accessors**: Expose remaining cooldowns:
  ```csharp
  public float LaughCooldownRemaining => Mathf.Max(0f, laughCooldown - (Time.time - lastLaughTime));
  ```
  
- [ ] **Networking safety**: All combat actions should use RPCs (handled in base class)
  
- [ ] **Speed management**: `GetMoveSpeed()` override:
  - MUST check `isBusy`, `globalBusyTimer`, `activeAbility`, `basicRoutine` first
  - MUST check `aiState == AIState.Idle` before returning base speed
  - Prevents animator speed parameter from showing incorrect values when stopped

## Common Pitfalls to Avoid

1. **Returning Success immediately**: Don't return `NodeState.Success` from `PerformBasicAttack()` - use coroutines
2. **Forgetting to clear coroutines**: Always set tracking fields to `null` when done
3. **Setting cooldown timers too early**: Set timers AFTER all recovery phases complete
4. **Not checking global busy**: Check `isBusy` AND `globalBusyTimer` in ability checks
5. **Hardcoded values**: Always expose tuning values in Inspector
6. **No post-attack lock**: Basic attacks need post-stop duration from `attackMoveLock`
7. **Missing movement freeze**: Always freeze AI during stoppage with `SimpleMove(Vector3.zero)`
8. **Charge/dash wrong direction**: **ALWAYS** face target during windup with `Quaternion.RotateTowards` loop
9. **Multiple hits on same player**: Use `HashSet<PlayerStats>` to track hit players in continuous attacks
10. **Using SimpleMove for charges**: Use `controller.Move()` for physics-based charge movement
11. **No separate windup trigger**: Charge/dash needs separate windup, charge, and stoppage animation triggers
12. **Basic attacks during charge**: Basic attack MUST check `activeAbility != null` to prevent interruption
13. **Recovery stops movement**: Recovery time MUST allow movement - call `EndAction()` after stoppage, not after recovery
14. **Teleporting to current position**: **ALWAYS** capture target position when ability starts, NOT during windup
15. **Missing basic attack windup**: Basic attacks MUST use `enemyData.attackWindup` and separate triggers if available
16. **No separate skill triggers**: All skills MUST use separate `abilityWindupTrigger` and `abilityMainTrigger` (not a single trigger)
17. **Shared VFX offsets/scales**: All skills MUST use separate `abilityWindupVFXOffset/Scale` and `abilityImpactVFXOffset/Scale` (not shared values)
18. **Speed stuck at base value**: **ALWAYS** check `aiState == AIState.Idle` in `GetMoveSpeed()` to return 0 when idle
19. **Patrol wait showing speed**: During patrol wait phase, set `aiState = AIState.Idle` and call `controller.SimpleMove(Vector3.zero)` to ensure speed is 0
20. **Charge/dash rotation lock**: **NEVER** face player during windup - capture direction BEFORE windup, then lock rotation during windup

## Testing Checklist

- [ ] Enemy never performs two actions simultaneously
- [ ] Special abilities properly interrupt/override each other based on priority
- [ ] Basic attacks don't interrupt special abilities
- [ ] Basic attacks can't be interrupted by specials once started
- [ ] Movement gradually recovers after special abilities
- [ ] Global 4-second skill lock works after ANY skill completes
- [ ] Cooldowns from Inspector are respected
- [ ] Debug overhead UI shows correct cooldown timers
- [ ] Animation triggers fire at correct times
- [ ] VFX/SFX play at correct times
- [ ] Damage is applied only to valid targets within area
- [ ] **Charge/Dash**: AI faces target correctly during windup
- [ ] **Charge/Dash**: AI charges in correct direction (toward target)
- [ ] **Charge/Dash**: Each player only takes damage ONCE during entire charge
- [ ] **Charge/Dash**: AI cannot perform basic attacks while charging
- [ ] **Charge/Dash**: Windup, charge, and stoppage animations trigger separately
- [ ] **Basic Attack**: Windup and impact animations trigger separately
- [ ] **Basic Attack**: Movement frozen during windup, damage applied after windup
- [ ] **Teleporting**: Target position captured when ability starts, not during windup
- [ ] **Teleporting**: AI teleports to where player was FIRST LOCATED, not current position
- [ ] **Recovery**: AI can move during recovery (no frozen state)
- [ ] **Recovery**: Speed gradually recovers from 30% to 100% during recovery
- [ ] **Skills**: All skills use separate windup and impact/main animation triggers
- [ ] **Skills**: All skills use separate windup and impact VFX offsets/scales
- [ ] **Skills**: Windup trigger fires during windup phase, impact/main trigger fires when damage is applied
- [ ] **Speed Management**: Animator speed parameter shows 0 when AI is stopped/idle/busy
- [ ] **Speed Management**: Speed correctly shows 0 during patrol wait phase (not stuck at patrol speed)
- [ ] **Speed Management**: Speed correctly shows 0 when AI reaches patrol destination
- [ ] **Charge/Dash**: Rotation is locked during windup (doesn't continuously face player)

## Reference Examples

- **Basic implementation**: `BungisngisAI.cs` - Simple two-special enemy with recovery system
- **Advanced implementation**: `AmomongoAI.cs` - Three abilities with windup/post-stop
- **Complex implementation**: `BerberokaAI.cs` - Multiple abilities with varying mechanics
- **Charge/Dash reference**: `TikbalangAI.cs` - Charge attack with windup facing, separate triggers, and one-hit-per-player tracking
- **Teleporting reference**: `KapreAI.cs` - Teleport strike with position capture, separate triggers, and recovery system

Apply to: `Assets/Enemies/**/*AI.cs`